---
title: Drivers
description: Built-in storage providers and guide to creating custom drivers
---

Storage providers (also called drivers) are responsible for storing and retrieving data from various backends. Vercube includes built-in providers and makes it easy to create custom ones for any storage backend.

## Built-in Providers

### MemoryStorage

The MemoryStorage provider stores data in memory. It's fast and ideal for caching and temporary data storage.

**Usage:**

```ts
import { StorageManager } from '@vercube/storage';
import { MemoryStorage } from '@vercube/storage/drivers/MemoryStorage';

container.bind(StorageManager);

const storageManager = container.get(StorageManager);
storageManager.mount({
  name: 'cache',
  storage: MemoryStorage
});

// Store data
await storageManager.setItem({
  storage: 'cache',
  key: 'mykey',
  value: { foo: 'bar' }
});

// Retrieve data
const value = await storageManager.getItem({
  storage: 'cache',
  key: 'mykey'
});
console.log(value); // { foo: 'bar' }
```

**Characteristics:**

| Feature | Description |
|---------|-------------|
| Persistence | None - data is lost on restart |
| Speed | Extremely fast |
| Memory Usage | Grows with stored data |
| Use Cases | Caching, temporary data, development |

**Best Practices:**

- Use for caching frequently accessed data
- Ideal for development and testing
- Clear periodically to prevent memory leaks
- Consider size limits for production use

---

### S3Storage

The S3Storage provider stores data in AWS S3 (or S3-compatible services like MinIO, DigitalOcean Spaces, etc.). It's ideal for distributed applications, serverless environments, and persistent cloud storage.

**Installation:**

You need to install the AWS SDK for S3:

::code-group
  ```bash [pnpm]
  $ pnpm add @aws-sdk/client-s3
  ```
  ```bash [npm]
  $ npm install @aws-sdk/client-s3
  ```
  ```bash [bun]
  $ bun install @aws-sdk/client-s3
  ```
::

**Usage:**

```ts
import { StorageManager } from '@vercube/storage';
import { S3Storage } from '@vercube/storage/drivers/S3Storage';

container.bind(StorageManager);

const storageManager = container.get(StorageManager);
storageManager.mount({
  name: 's3',
  storage: S3Storage,
  initOptions: {
    bucket: 'my-app-bucket',
    region: 'us-east-1',
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    }
  }
});

// Store data
await storageManager.setItem({
  storage: 's3',
  key: 'user:123',
  value: { id: '123', name: 'John' }
});

// Retrieve data
const user = await storageManager.getItem({
  storage: 's3',
  key: 'user:123'
});
```

**Configuration Options:**

The `initOptions` extends AWS S3ClientConfig with an additional `bucket` property:

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `bucket` | `string` | Yes | S3 bucket name |
| `region` | `string` | Yes | AWS region (e.g., 'us-east-1') |
| `credentials` | `object` | No | AWS credentials (accessKeyId, secretAccessKey) |
| `endpoint` | `string` | No | Custom endpoint for S3-compatible services |

**Using with S3-Compatible Services:**

```ts
// MinIO
storageManager.mount({
  name: 'minio',
  storage: S3Storage,
  initOptions: {
    bucket: 'my-bucket',
    region: 'us-east-1',
    endpoint: 'http://localhost:9000',
    credentials: {
      accessKeyId: 'minioadmin',
      secretAccessKey: 'minioadmin'
    },
    forcePathStyle: true // Required for MinIO
  }
});

// DigitalOcean Spaces
storageManager.mount({
  name: 'spaces',
  storage: S3Storage,
  initOptions: {
    bucket: 'my-space',
    region: 'nyc3',
    endpoint: 'https://nyc3.digitaloceanspaces.com',
    credentials: {
      accessKeyId: process.env.DO_SPACES_KEY,
      secretAccessKey: process.env.DO_SPACES_SECRET
    }
  }
});

// Cloudflare R2
storageManager.mount({
  name: 'r2',
  storage: S3Storage,
  initOptions: {
    bucket: 'my-bucket',
    region: 'auto',
    endpoint: `https://${process.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`,
    credentials: {
      accessKeyId: process.env.R2_ACCESS_KEY_ID,
      secretAccessKey: process.env.R2_SECRET_ACCESS_KEY
    }
  }
});
```

**Characteristics:**

| Feature | Description |
|---------|-------------|
| Persistence | Yes - data persists across restarts |
| Speed | Network-dependent (slower than memory) |
| Scalability | Highly scalable, distributed |
| Use Cases | Production storage, file storage, distributed apps |

**Best Practices:**

- Use environment variables for credentials
- Consider using IAM roles in AWS environments
- Implement caching layer (MemoryStorage) for frequently accessed data
- Use appropriate S3 bucket policies for security
- Consider S3 storage classes for cost optimization

---

## Creating Custom Providers

Creating a custom provider allows you to store data in any backend: databases, cloud storage, external services, etc.

### Basic Provider Template

```ts
import { Storage } from '@vercube/storage';
import type { StorageTypes } from '@vercube/storage';

export class CustomStorage extends Storage {
  private client: any; // Your storage client
  
  /**
   * Initialize the storage with options
   */
  public async initialize(options?: StorageTypes.Options): Promise<void> {
    // Setup code: connect to service, initialize client, etc.
    this.client = await connectToService(options);
  }
  
  /**
   * Retrieve a value by key
   */
  public async getItem<T>(key: string): Promise<T | null> {
    const data = await this.client.get(key);
    return data ? JSON.parse(data) : null;
  }
  
  /**
   * Store a value with a key
   */
  public async setItem<T>(key: string, value: T): Promise<void> {
    await this.client.set(key, JSON.stringify(value));
  }
  
  /**
   * Check if a key exists
   */
  public async hasItem(key: string): Promise<boolean> {
    return this.client.has(key);
  }
  
  /**
   * Remove a value by key
   */
  public async deleteItem(key: string): Promise<void> {
    await this.client.delete(key);
  }
  
  /**
   * Get all keys
   */
  public async getKeys(): Promise<string[]> {
    return this.client.keys();
  }
  
  /**
   * Remove all items
   */
  public async clear(): Promise<void> {
    await this.client.clear();
  }
  
  /**
   * Get the number of stored items
   */
  public async size(): Promise<number> {
    return this.client.size();
  }
}
```

### Required Methods

Every custom storage provider must implement these methods:

| Method | Description |
|--------|-------------|
| `initialize(options)` | Initialize the storage with configuration options |
| `getItem<T>(key)` | Retrieve a value by key |
| `setItem<T, U>(key, value, options?)` | Store a value with a key and optional options |
| `hasItem(key)` | Check if a key exists |
| `deleteItem(key)` | Remove a value by key |
| `getKeys()` | Get all keys |
| `clear()` | Remove all items |
| `size()` | Get the number of stored items |

---

## Example: Redis Storage

A complete example of a Redis storage provider:

```ts
import { Storage } from '@vercube/storage';
import type { StorageTypes } from '@vercube/storage';
import Redis from 'ioredis';

interface RedisStorageOptions {
  host: string;
  port: number;
  password?: string;
  db?: number;
  keyPrefix?: string;
}

export class RedisStorage extends Storage {
  private redis!: Redis;
  private prefix: string = '';
  
  public async initialize(options: RedisStorageOptions): Promise<void> {
    this.redis = new Redis({
      host: options.host,
      port: options.port,
      password: options.password,
      db: options.db || 0
    });
    
    this.prefix = options.keyPrefix || '';
  }
  
  private getKey(key: string): string {
    return this.prefix + key;
  }
  
  public async getItem<T>(key: string): Promise<T | null> {
    const data = await this.redis.get(this.getKey(key));
    return data ? JSON.parse(data) : null;
  }
  
  public async setItem<T>(key: string, value: T): Promise<void> {
    await this.redis.set(this.getKey(key), JSON.stringify(value));
  }
  
  public async hasItem(key: string): Promise<boolean> {
    const exists = await this.redis.exists(this.getKey(key));
    return exists === 1;
  }
  
  public async deleteItem(key: string): Promise<void> {
    await this.redis.del(this.getKey(key));
  }
  
  public async getKeys(): Promise<string[]> {
    const keys = await this.redis.keys(this.prefix + '*');
    return keys.map(k => k.replace(this.prefix, ''));
  }
  
  public async clear(): Promise<void> {
    const keys = await this.redis.keys(this.prefix + '*');
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
  
  public async size(): Promise<number> {
    const keys = await this.redis.keys(this.prefix + '*');
    return keys.length;
  }
}
```

**Usage:**

```ts
import { StorageManager } from '@vercube/storage';
import { RedisStorage } from './storages/RedisStorage';

// Register custom storage in container
container.bind(RedisStorage);

const storageManager = container.get(StorageManager);

// Mount custom storage
storageManager.mount({
  name: 'redis',
  storage: RedisStorage,
  initOptions: {
    host: 'localhost',
    port: 6379,
    keyPrefix: 'myapp:'
  }
});

// Use it like any other storage
await storageManager.setItem({
  storage: 'redis',
  key: 'user:123',
  value: { name: 'John' }
});
```

---

## Example: File System Storage

A storage provider that persists data to the file system:

```ts
import { Storage } from '@vercube/storage';
import type { StorageTypes } from '@vercube/storage';
import * as fs from 'fs/promises';
import * as path from 'path';

interface FileStorageOptions {
  directory: string;
}

export class FileStorage extends Storage {
  private directory!: string;
  
  public async initialize(options: FileStorageOptions): Promise<void> {
    this.directory = options.directory;
    
    // Ensure directory exists
    await fs.mkdir(this.directory, { recursive: true });
  }
  
  private getFilePath(key: string): string {
    // Sanitize key for use as filename
    const safeKey = key.replace(/[^a-zA-Z0-9-_:]/g, '_');
    return path.join(this.directory, `${safeKey}.json`);
  }
  
  public async getItem<T>(key: string): Promise<T | null> {
    try {
      const filePath = this.getFilePath(key);
      const data = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(data);
    } catch (error) {
      return null;
    }
  }
  
  public async setItem<T>(key: string, value: T): Promise<void> {
    const filePath = this.getFilePath(key);
    await fs.writeFile(filePath, JSON.stringify(value, null, 2));
  }
  
  public async hasItem(key: string): Promise<boolean> {
    try {
      await fs.access(this.getFilePath(key));
      return true;
    } catch {
      return false;
    }
  }
  
  public async deleteItem(key: string): Promise<void> {
    try {
      await fs.unlink(this.getFilePath(key));
    } catch {
      // Ignore if file doesn't exist
    }
  }
  
  public async getKeys(): Promise<string[]> {
    const files = await fs.readdir(this.directory);
    return files
      .filter(f => f.endsWith('.json'))
      .map(f => f.replace('.json', ''));
  }
  
  public async clear(): Promise<void> {
    const files = await fs.readdir(this.directory);
    for (const file of files) {
      if (file.endsWith('.json')) {
        await fs.unlink(path.join(this.directory, file));
      }
    }
  }
  
  public async size(): Promise<number> {
    const keys = await this.getKeys();
    return keys.length;
  }
}
```

**Usage:**

```ts
storageManager.mount({
  name: 'files',
  storage: FileStorage,
  initOptions: {
    directory: './data/storage'
  }
});

await storageManager.setItem({
  storage: 'files',
  key: 'config',
  value: { theme: 'dark' }
});
```

---

## Provider Configuration

### Register Provider in Container

If your provider has dependencies, register it in the container:

```ts
import { Container } from '@vercube/di';
import { CustomStorage } from './storages/CustomStorage';

export function setupContainer(container: Container): void {
  // Register provider
  container.bind(CustomStorage);
  
  // Configure storage manager to use it
  const storageManager = container.get(StorageManager);
  storageManager.mount({
    name: 'custom',
    storage: CustomStorage,
    initOptions: { ... }
  });
}
```

### Provider with Dependencies

If your provider needs other services:

```ts
import { Inject } from '@vercube/di';
import { Storage } from '@vercube/storage';
import { Logger } from '@vercube/logger';

export class LoggingStorage extends Storage {
  @Inject(Logger)
  private logger!: Logger;
  
  private innerStorage!: Storage;
  
  public async initialize(options: { storage: Storage }): Promise<void> {
    this.innerStorage = options.storage;
  }
  
  public async getItem<T>(key: string): Promise<T | null> {
    this.logger.debug(`Getting item: ${key}`);
    const value = await this.innerStorage.getItem<T>(key);
    this.logger.debug(`Got item: ${key}`, { found: value !== null });
    return value;
  }
  
  public async setItem<T>(key: string, value: T): Promise<void> {
    this.logger.debug(`Setting item: ${key}`);
    await this.innerStorage.setItem(key, value);
    this.logger.info(`Item set: ${key}`);
  }
  
  // ... implement other methods with logging
}
```

### Async Initialization

If your provider needs async initialization:

```ts
export class AsyncStorage extends Storage {
  private connection: Connection;
  
  public async initialize(options: ConnectionOptions): Promise<void> {
    // Async initialization is fully supported
    this.connection = await connectToService(options);
    
    // Wait for connection to be ready
    await this.connection.ready();
  }
  
  // ... implement other methods
}
```

---

## Using Multiple Providers

Configure multiple providers for different use cases:

```ts
import { StorageManager } from '@vercube/storage';
import { MemoryStorage } from '@vercube/storage/drivers/MemoryStorage';
import { S3Storage } from '@vercube/storage/drivers/S3Storage';
import { RedisStorage } from './storages/RedisStorage';

const storageManager = container.get(StorageManager);

// Memory for fast local cache
storageManager.mount({
  name: 'cache',
  storage: MemoryStorage
});

// S3 for persistent cloud storage
storageManager.mount({
  name: 's3',
  storage: S3Storage,
  initOptions: {
    bucket: process.env.S3_BUCKET,
    region: process.env.AWS_REGION,
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    }
  }
});

// Redis for distributed cache
storageManager.mount({
  name: 'distributed',
  storage: RedisStorage,
  initOptions: {
    host: process.env.REDIS_HOST,
    port: 6379,
    keyPrefix: 'app:'
  }
});

```

---

## Troubleshooting

### Provider Not Storing Data

**Problem:** `setItem()` works but `getItem()` returns null

**Solutions:**

1. Check serialization/deserialization:
```ts
// Make sure data can be serialized
await storage.setItem('key', {
  date: new Date().toISOString(), // ✅ Serialize dates as strings
  // date: new Date(), // ❌ May not deserialize correctly
});
```

2. Verify key format is consistent:
```ts
// Use consistent key formatting
await storage.setItem('user:123', data);
const value = await storage.getItem('user:123'); // ✅ Same key

// Not this:
await storage.setItem('user:123', data);
const value = await storage.getItem('user-123'); // ❌ Different key
```

### Provider Initialization Error

**Problem:** "Failed to initialize storage provider"

**Solutions:**

1. Check `initialize()` method doesn't throw:
```ts
public async initialize(options: any): Promise<void> {
  try {
    // initialization code
  } catch (error) {
    console.error('Storage init failed:', error);
    // Don't throw - handle gracefully
  }
}
```

2. Verify provider is bound in container:
```ts
container.bind(CustomStorage);
```

3. Check provider initOptions:
```ts
storageManager.mount({
  name: 'custom',
  storage: CustomStorage,
  initOptions: {
    // Make sure all required options are provided
    requiredOption: 'value'
  }
});
```

### Provider Missing Dependency

**Problem:** Injected dependency is undefined

**Solution:** Make sure dependency is registered before storage configuration:

```ts
// Register dependencies first
container.bind(Logger);
container.bind(CustomStorage);

// Then configure storage
container.bind(StorageManager);
const storageManager = container.get(StorageManager);
storageManager.mount({
  name: 'custom',
  storage: CustomStorage
});
```

### Async Provider Not Working

**Problem:** Async `initialize()` doesn't complete before use

**Solution:** StorageManager handles async initialization automatically. Make sure you're using `await` when needed:

```ts
// Initialize is called automatically when mounting
storageManager.mount({
  name: 'async',
  storage: AsyncStorage,
  initOptions: { ... }
});

// Storage is ready to use after mount
await storageManager.setItem({
  storage: 'async',
  key: 'mykey',
  value: 'myvalue'
});
```

